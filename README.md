# 同步互斥
同步互斥解法-软件
写的比较详细的博客：https://blog.csdn.net/JustJavaC2016/article/details/78660768

软件解法特点、局限
首先，单核CPU下目前已知的纯软件同步互斥解法都有忙等待问题(活锁)，进程在判断是否有进程在临界区时要进入一个while循环

while(有进程在临界区)；    //有进程在临界区，等待，无则进入
        临界区操作；

局限一：进程的执行效率与时间片大小以及临界区内操作时间关系很大，如果临界区操作时间很短但次数很多，程序效率会很低，因为很多时间浪费在了while循环上（活锁），后面我会给出实际运行的例子。
办法：采用"分治"思想，尽量减少临界区操作次数，加大每次临界区内操作时长

局限二：对程序编写有一定要求，尤其在多进程互斥访问时，代码难管理
办法：无
              
优势：无需系统调用，无内核/用户态切换，且对多核CPU同样有效

比较典型的有DEKKER和PETERSON算法

缺点：强制轮流
假设P刚完成一次执行，turn值修改为2，此时若pturn为true，那么P就会卡在while循环。
换句话说，如果两个进程都想一直执行，那么他们必须轮流执行
程序执行流一定是PQPQPQPQPQPQPQPQ而不会是PPQ或者QQP
不过这在一定程度上也避免了饥饿
 
PETERSON

除了有点绕，没啥缺点
但进入临界区前要先经过一个while循环，可能会产生活锁
如果能优化，把while改为if，效果会很好
————————————————————————————————————————————————————————————————————————————————————————————————————
同步互斥解法-硬件

原理都是加锁-临界区操作-解锁，加解锁都是原子操作，要切内核态
分线程和进程，优化在于减少内核-用户态切换次数
